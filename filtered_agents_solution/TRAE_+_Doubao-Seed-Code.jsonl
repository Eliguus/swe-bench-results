{"instance_id": "django__django-14608", "model_patch": "diff --git a/django/forms/formsets.py b/django/forms/formsets.py\nindex a89c35599f..1b0d4554e0 100644\n--- a/django/forms/formsets.py\n+++ b/django/forms/formsets.py\n@@ -333,7 +333,7 @@ class BaseFormSet:\n         self._non_form_errors.\n         \"\"\"\n         self._errors = []\n-        self._non_form_errors = self.error_class()\n+        self._non_form_errors = self.error_class(error_class='nonform')\n         empty_forms_count = 0\n \n         if not self.is_bound:  # Stop further processing.\n@@ -380,7 +380,7 @@ class BaseFormSet:\n             # Give self.clean() a chance to do cross-form validation.\n             self.clean()\n         except ValidationError as e:\n-            self._non_form_errors = self.error_class(e.error_list)\n+            self._non_form_errors = self.error_class(e.error_list, error_class='nonform')\n \n     def clean(self):\n         \"\"\"\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-13779", "model_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex 7afa7180c..13accdcec 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -78,7 +78,7 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n \n         if sample_weight is not None:\n             for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n+                if step is not None and not has_fit_parameter(step, 'sample_weight'):\n                     raise ValueError('Underlying estimator \\'%s\\' does not'\n                                      ' support sample weights.' % name)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-13031", "model_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..577b7cd730 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -377,8 +377,10 @@ def hstack(cls, *args):\n         if len(args) == 0:\n             return cls._new()\n \n-        kls = type(args[0])\n-        return reduce(kls.row_join, args)\n+        result = args[0]\n+        for other in args[1:]:\n+            result = result.row_join(other)\n+        return result\n \n     def reshape(self, rows, cols):\n         \"\"\"Reshape the matrix. Total number of elements must remain the same.\n@@ -600,8 +602,10 @@ def vstack(cls, *args):\n         if len(args) == 0:\n             return cls._new()\n \n-        kls = type(args[0])\n-        return reduce(kls.col_join, args)\n+        result = args[0]\n+        for other in args[1:]:\n+            result = result.col_join(other)\n+        return result\n \n \n class MatrixSpecial(MatrixRequired):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-14087", "model_patch": "diff --git a/sklearn/linear_model/logistic.py b/sklearn/linear_model/logistic.py\nindex 1999f1dae..470bc2a3d 100644\n--- a/sklearn/linear_model/logistic.py\n+++ b/sklearn/linear_model/logistic.py\n@@ -2170,7 +2170,7 @@ class LogisticRegressionCV(LogisticRegression, BaseEstimator,\n                 # Take the best scores across every fold and the average of\n                 # all coefficients corresponding to the best scores.\n                 best_indices = np.argmax(scores, axis=1)\n-                if self.multi_class == 'ovr':\n+                if multi_class == 'ovr':\n                     w = np.mean([coefs_paths[i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n                 else:\n@@ -2181,7 +2181,9 @@ class LogisticRegressionCV(LogisticRegression, BaseEstimator,\n                 self.C_.append(np.mean(self.Cs_[best_indices_C]))\n \n                 best_indices_l1 = best_indices // len(self.Cs_)\n-                self.l1_ratio_.append(np.mean(l1_ratios_[best_indices_l1]))\n+                # For non-elasticnet, all l1_ratio values are the same (None)\n+                self.l1_ratio_.append(l1_ratios_[best_indices_l1[0]] if len(l1_ratios_) == 1 \n+                                     else np.mean([l1_ratios_[i] for i in best_indices_l1]))\n \n             if multi_class == 'multinomial':\n                 self.C_ = np.tile(self.C_, n_classes)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..1f521cfc5c 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "astropy__astropy-14995", "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..c6529d0f6e 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -512,19 +512,13 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n-        # If only one mask is present we need not bother about any type checks\n-        if (\n-            self.mask is None and operand is not None and operand.mask is None\n-        ) or handle_mask is None:\n-            return None\n-        elif self.mask is None and operand is not None:\n-            # Make a copy so there is no reference in the result.\n-            return deepcopy(operand.mask)\n-        elif operand is None:\n+        # If one or both masks are None, return the one that's not None (or None if both are None)\n+        if self.mask is None:\n+            return deepcopy(operand.mask) if operand is not None else None\n+        if operand is None or operand.mask is None:\n             return deepcopy(self.mask)\n-        else:\n-            # Now lets calculate the resulting mask (operation enforces copy)\n-            return handle_mask(self.mask, operand.mask, **kwds)\n+        # Both have masks, apply handle_mask\n+        return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n         \"\"\"\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13964", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 2428218696..8456d92410 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -933,10 +933,10 @@ class Model(metaclass=ModelBase):\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, field.name)\n                     )\n-                elif getattr(self, field.attname) is None:\n+                elif getattr(self, field.attname) != getattr(obj, field.target_field.attname):\n                     # Use pk from related object if it has been saved after\n                     # an assignment.\n-                    setattr(self, field.attname, obj.pk)\n+                    setattr(self, field.attname, getattr(obj, field.target_field.attname))\n                 # If the relationship's pk/to_field was changed, clear the\n                 # cached relationship.\n                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-18698", "model_patch": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex c9e77a901f..b5f5a9603f 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5995,6 +5995,19 @@ def _generic_factor_list(expr, gens, args, method):\n                     f, _ = _poly_from_expr(f, _opt)\n                     factors[i] = (f, k)\n \n+        if method == 'sqf':\n+            # Group factors by exponent for square-free decomposition\n+            from collections import defaultdict\n+            fp_dict = defaultdict(lambda: 1)\n+            for f, k in fp:\n+                fp_dict[k] = fp_dict[k] * f\n+            fp = [(f, k) for k, f in fp_dict.items()]\n+            \n+            fq_dict = defaultdict(lambda: 1)\n+            for f, k in fq:\n+                fq_dict[k] = fq_dict[k] * f\n+            fq = [(f, k) for k, f in fq_dict.items()]\n+\n         fp = _sorted_factors(fp, method)\n         fq = _sorted_factors(fq, method)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-15695", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex d17232e4ec..47e3924445 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -920,12 +920,19 @@ class RenameIndex(IndexOperation):\n                 self.model_name_lower,\n                 models.Index(fields=self.old_fields, name=self.new_name),\n             )\n+            # Try to remove from both index_together and unique_together\n             state.remove_model_options(\n                 app_label,\n                 self.model_name_lower,\n                 AlterIndexTogether.option_name,\n                 self.old_fields,\n             )\n+            state.remove_model_options(\n+                app_label,\n+                self.model_name_lower,\n+                AlterUniqueTogether.option_name,\n+                self.old_fields,\n+            )\n         else:\n             state.rename_index(\n                 app_label, self.model_name_lower, self.old_name, self.new_name\n@@ -966,23 +973,35 @@ class RenameIndex(IndexOperation):\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n-        if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n+        model = to_state.apps.get_model(app_label, self.model_name)\n+        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n             return\n \n-        self.new_name_lower, self.old_name_lower = (\n-            self.old_name_lower,\n-            self.new_name_lower,\n-        )\n-        self.new_name, self.old_name = self.old_name, self.new_name\n+        if self.old_fields:\n+            # For unnamed index, we need to get the auto-generated name\n+            old_index = models.Index(\n+                fields=self.old_fields,\n+                name=self.new_name,\n+            )\n+            new_index = models.Index(\n+                fields=self.old_fields,\n+            )\n+            new_index.set_name_with_model(model)\n+            schema_editor.rename_index(model, old_index, new_index)\n+        else:\n+            self.new_name_lower, self.old_name_lower = (\n+                self.old_name_lower,\n+                self.new_name_lower,\n+            )\n+            self.new_name, self.old_name = self.old_name, self.new_name\n \n-        self.database_forwards(app_label, schema_editor, from_state, to_state)\n+            self.database_forwards(app_label, schema_editor, from_state, to_state)\n \n-        self.new_name_lower, self.old_name_lower = (\n-            self.old_name_lower,\n-            self.new_name_lower,\n-        )\n-        self.new_name, self.old_name = self.old_name, self.new_name\n+            self.new_name_lower, self.old_name_lower = (\n+                self.old_name_lower,\n+                self.new_name_lower,\n+            )\n+            self.new_name, self.old_name = self.old_name, self.new_name\n \n     def describe(self):\n         if self.old_name:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-16792", "model_patch": "diff --git a/sympy/utilities/codegen.py b/sympy/utilities/codegen.py\nindex f0befb2bd7..086ecc5149 100644\n--- a/sympy/utilities/codegen.py\n+++ b/sympy/utilities/codegen.py\n@@ -700,6 +700,14 @@ def routine(self, name, expr, argument_sequence=None, global_vars=None):\n             array_symbols[array.base.label] = array\n         for array in expressions.atoms(MatrixSymbol) | local_expressions.atoms(MatrixSymbol):\n             array_symbols[array] = array\n+        \n+        # Also check argument_sequence for arrays that might not be in expressions\n+        if argument_sequence is not None:\n+            for arg in argument_sequence:\n+                if isinstance(arg, MatrixSymbol):\n+                    array_symbols[arg] = arg\n+                elif isinstance(arg, IndexedBase):\n+                    array_symbols[arg.label] = arg\n \n         for symbol in sorted(symbols, key=str):\n             if symbol in array_symbols:\n@@ -739,7 +747,15 @@ def routine(self, name, expr, argument_sequence=None, global_vars=None):\n                 try:\n                     new_args.append(name_arg_dict[symbol])\n                 except KeyError:\n-                    new_args.append(InputArgument(symbol))\n+                    # Check if symbol is an array type\n+                    if symbol in array_symbols:\n+                        dims = []\n+                        array = array_symbols[symbol]\n+                        for dim in array.shape:\n+                            dims.append((S.Zero, dim - 1))\n+                        new_args.append(InputArgument(symbol, dimensions=dims))\n+                    else:\n+                        new_args.append(InputArgument(symbol))\n             arg_list = new_args\n \n         return Routine(name, arg_list, return_val, local_vars, global_vars)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14787", "model_patch": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..8b9da17e31 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -38,6 +38,7 @@ def _multi_decorate(decorators, method):\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n         bound_method = partial(method.__get__(self, type(self)))\n+        update_wrapper(bound_method, method)\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-18199", "model_patch": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..fd23b2c66c 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -768,13 +768,19 @@ def nthroot_mod(a, n, p, all_roots=False):\n     \"\"\"\n     from sympy.core.numbers import igcdex\n     a, n, p = as_int(a), as_int(n), as_int(p)\n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+    # Check if a â‰¡ 0 mod p\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n     if n == 2:\n         return sqrt_mod(a, p, all_roots)\n     # see Hackman \"Elementary Number Theory\" (2009), page 76\n     if not is_nthpow_residue(a, n, p):\n         return None\n-    if not isprime(p):\n-        raise NotImplementedError(\"Not implemented for composite p\")\n \n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-21379", "model_patch": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\nindex 860989f7c1..2efcceda9a 100644\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -1,12 +1,13 @@\n from sympy.core.logic import FuzzyBool\n \n-from sympy.core import S, sympify, cacheit, pi, I, Rational\n+from sympy.core import S, sympify, cacheit, pi, I, Rational, Basic\n from sympy.core.add import Add\n from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg\n from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n from sympy.functions.elementary.exponential import exp, log, match_real_imag\n from sympy.functions.elementary.miscellaneous import sqrt\n from sympy.functions.elementary.integers import floor\n+from sympy.polys.polyerrors import PolynomialError\n \n from sympy.core.logic import fuzzy_or, fuzzy_and\n \n@@ -248,7 +249,15 @@ def _eval_is_real(self):\n         # if `im` is of the form n*pi\n         # else, check if it is a number\n         re, im = arg.as_real_imag()\n-        return (im%pi).is_zero\n+        # First check if im is zero\n+        if im.is_zero:\n+            return True\n+        # Otherwise check if it's a multiple of pi\n+        try:\n+            return (im%pi).is_zero\n+        except (TypeError, PolynomialError):\n+            # If we can't compute the modulus, return None\n+            return None\n \n     def _eval_is_extended_real(self):\n         if self.args[0].is_extended_real:\n@@ -437,7 +446,12 @@ def _eval_is_real(self):\n         # the imaginary part can be an expression like n*pi\n         # if not, check if the imaginary part is a number\n         re, im = arg.as_real_imag()\n-        return (im%pi).is_zero\n+        if im.is_zero:\n+            return True\n+        try:\n+            return (im%pi).is_zero\n+        except (TypeError, PolynomialError):\n+            return None\n \n     def _eval_is_positive(self):\n         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)\n@@ -448,9 +462,12 @@ def _eval_is_positive(self):\n         z = self.args[0]\n \n         x, y = z.as_real_imag()\n-        ymod = y % (2*pi)\n+        try:\n+            ymod = y % (2*pi)\n+        except (TypeError, PolynomialError):\n+            return None\n \n-        yzero = ymod.is_zero\n+        yzero = ymod.is_zero if isinstance(ymod, Basic) else ymod == 0\n         # shortcut if ymod is zero\n         if yzero:\n             return True\n@@ -460,24 +477,30 @@ def _eval_is_positive(self):\n         if xzero is False:\n             return yzero\n \n-        return fuzzy_or([\n-                # Case 1:\n-                yzero,\n-                # Case 2:\n-                fuzzy_and([\n-                    xzero,\n-                    fuzzy_or([ymod < pi/2, ymod > 3*pi/2])\n+        try:\n+            return fuzzy_or([\n+                    # Case 1:\n+                    yzero,\n+                    # Case 2:\n+                    fuzzy_and([\n+                        xzero,\n+                        fuzzy_or([ymod < pi/2, ymod > 3*pi/2])\n+                    ])\n                 ])\n-            ])\n+        except (TypeError, PolynomialError):\n+            return None\n \n \n     def _eval_is_nonnegative(self):\n         z = self.args[0]\n \n         x, y = z.as_real_imag()\n-        ymod = y % (2*pi)\n+        try:\n+            ymod = y % (2*pi)\n+        except (TypeError, PolynomialError):\n+            return None\n \n-        yzero = ymod.is_zero\n+        yzero = ymod.is_zero if isinstance(ymod, Basic) else ymod == 0\n         # shortcut if ymod is zero\n         if yzero:\n             return True\n@@ -487,15 +510,18 @@ def _eval_is_nonnegative(self):\n         if xzero is False:\n             return yzero\n \n-        return fuzzy_or([\n-                # Case 1:\n-                yzero,\n-                # Case 2:\n-                fuzzy_and([\n-                    xzero,\n-                    fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])\n+        try:\n+            return fuzzy_or([\n+                    # Case 1:\n+                    yzero,\n+                    # Case 2:\n+                    fuzzy_and([\n+                        xzero,\n+                        fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])\n+                    ])\n                 ])\n-            ])\n+        except (TypeError, PolynomialError):\n+            return None\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -658,12 +684,18 @@ def _eval_is_real(self):\n         re, im = arg.as_real_imag()\n \n         # if denom = 0, tanh(arg) = zoo\n-        if re == 0 and im % pi == pi/2:\n-            return None\n+        try:\n+            if re == 0 and (im % pi) == pi/2:\n+                return None\n+        except (TypeError, PolynomialError):\n+            pass\n \n         # check if im is of the form n*pi/2 to make sin(2*im) = 0\n         # if not, im could be a number, return False in that case\n-        return (im % (pi/2)).is_zero\n+        try:\n+            return (im % (pi/2)).is_zero\n+        except (TypeError, PolynomialError):\n+            return None\n \n     def _eval_is_extended_real(self):\n         if self.args[0].is_extended_real:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13658", "model_patch": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 1ba093e51f..44d8b6a209 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -344,7 +344,11 @@ class ManagementUtility:\n         # Preprocess options to extract --settings and --pythonpath.\n         # These options could affect the commands that are available, so they\n         # must be processed early.\n-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)\n+        parser = CommandParser(\n+            prog=self.prog_name,\n+            usage='%(prog)s subcommand [options] [args]',\n+            add_help=False,\n+            allow_abbrev=False)\n         parser.add_argument('--settings')\n         parser.add_argument('--pythonpath')\n         parser.add_argument('args', nargs='*')  # catch-all\n@@ -380,7 +384,7 @@ class ManagementUtility:\n                     # (e.g. options for the contrib.staticfiles' runserver).\n                     # Changes here require manually testing as described in\n                     # #27522.\n-                    _parser = self.fetch_command('runserver').create_parser('django', 'runserver')\n+                    _parser = self.fetch_command('runserver').create_parser(self.prog_name, 'runserver')\n                     _options, _args = _parser.parse_known_args(self.argv[2:])\n                     for _arg in _args:\n                         self.argv.remove(_arg)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-16255", "model_patch": "diff --git a/django/contrib/sitemaps/__init__.py b/django/contrib/sitemaps/__init__.py\nindex 27756d9d96..b40ad806ed 100644\n--- a/django/contrib/sitemaps/__init__.py\n+++ b/django/contrib/sitemaps/__init__.py\n@@ -168,7 +168,7 @@ class Sitemap:\n         if callable(self.lastmod):\n             try:\n                 return max([self.lastmod(item) for item in self.items()])\n-            except TypeError:\n+            except (TypeError, ValueError):\n                 return None\n         else:\n             return self.lastmod\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-23476", "model_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..dd8bfa6ec0 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1653,7 +1653,17 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            # If this is an old figure being unpickled that doesn't have\n+            # _original_dpi, we need to assume the current dpi is already\n+            # scaled by device_pixel_ratio, so we divide by it to get the\n+            # original logical DPI. But wait, we don't know the ratio yet!\n+            # Actually no - wait! If _original_dpi doesn't exist, this means\n+            # the figure was created before _original_dpi was introduced,\n+            # OR it was created without going through FigureCanvasBase.__init__\n+            # (like unpickling). In either case, we should preserve the current\n+            # dpi as the original, because set_device_pixel_ratio will multiply it.\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-18189", "model_patch": "diff --git a/sympy/solvers/diophantine.py b/sympy/solvers/diophantine.py\nindex 6092e35dab..8c270aeb3b 100644\n--- a/sympy/solvers/diophantine.py\n+++ b/sympy/solvers/diophantine.py\n@@ -180,9 +180,9 @@ def diophantine(eq, param=symbols(\"t\", integer=True), syms=None,\n                     'syms should be given as a sequence, e.g. a list')\n             syms = [i for i in syms if i in var]\n             if syms != var:\n-                dict_sym_index = dict(zip(syms, range(len(syms))))\n-                return {tuple([t[dict_sym_index[i]] for i in var])\n-                            for t in diophantine(eq, param)}\n+                dict_var_index = dict(zip(var, range(len(var))))\n+                return {tuple([t[dict_var_index[s]] for s in syms])\n+                            for t in diophantine(eq, param, permute=permute)}\n         n, d = eq.as_numer_denom()\n         if n.is_number:\n             return set()\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-17139", "model_patch": "diff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py\nindex ad1130ef96..aaafeb6a01 100644\n--- a/sympy/simplify/fu.py\n+++ b/sympy/simplify/fu.py\n@@ -501,7 +501,8 @@ def _f(rv):\n         if not (rv.is_Pow and rv.base.func == f):\n             return rv\n \n-        if (rv.exp < 0) == True:\n+        # Only apply transformation to positive integer exponents\n+        if not (rv.exp.is_Integer and rv.exp.is_positive):\n             return rv\n         if (rv.exp > max) == True:\n             return rv\n@@ -1788,7 +1789,7 @@ def process_common_addends(rv, do, key2=None, key1=True):\n     if key1:\n         for a in rv.args:\n             c, a = a.as_coeff_Mul()\n-            if c < 0:\n+            if c.is_real is True and c < 0:\n                 c = -c\n                 a = -a  # put the sign on `a`\n             absc[(c, key2(a) if key2 else 1)].append(a)\n@@ -2041,7 +2042,7 @@ def as_f_sign_1(e):\n     a, b = e.args\n     if a in (S.NegativeOne, S.One):\n         g = S.One\n-        if b.is_Mul and b.args[0].is_Number and b.args[0] < 0:\n+        if b.is_Mul and b.args[0].is_real is True and b.args[0] < 0:\n             a, b = -a, -b\n             g = -g\n         return g, b, a\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14155", "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..e720fac844 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,17 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+        # Handle functools.partial objects\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__qualname__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\n@@ -59,8 +64,19 @@ class ResolverMatch:\n         return (self.func, self.args, self.kwargs)[index]\n \n     def __repr__(self):\n+        if isinstance(self.func, functools.partial):\n+            func_repr = \"functools.partial(%s\" % self._func_path\n+            # Add positional args\n+            for arg in self.func.args:\n+                func_repr += \", %r\" % arg\n+            # Add keyword args\n+            for k, v in self.func.keywords.items():\n+                func_repr += \", %s=%r\" % (k, v)\n+            func_repr += \")\"\n+        else:\n+            func_repr = self._func_path\n         return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n-            self._func_path, self.args, self.kwargs, self.url_name,\n+            func_repr, self.args, self.kwargs, self.url_name,\n             self.app_names, self.namespaces, self.route,\n         )\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-10914", "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887d2..bdeec80610 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,7 @@ FILE_UPLOAD_TEMP_DIR = None\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-17630", "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..8192306e4e 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -148,11 +148,27 @@ def blocks(self):\n \n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle scalar zero\n+                sizes.append(0 if i == 0 else sizes[0])\n+        return sizes\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle scalar zero\n+                sizes.append(0 if i == 0 else sizes[0])\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n@@ -164,14 +180,38 @@ def structurally_equal(self, other):\n     def _blockmul(self, other):\n         if (isinstance(other, BlockMatrix) and\n                 self.colblocksizes == other.rowblocksizes):\n-            return BlockMatrix(self.blocks*other.blocks)\n+            # Compute block multiplication manually to preserve ZeroMatrix\n+            m, n = self.blockshape\n+            n2, p = other.blockshape\n+            result_blocks = []\n+            for i in range(m):\n+                row = []\n+                for j in range(p):\n+                    block_sum = None\n+                    for k in range(n):\n+                        product = self.blocks[i, k] * other.blocks[k, j]\n+                        if block_sum is None:\n+                            block_sum = product\n+                        else:\n+                            block_sum += product\n+                    row.append(block_sum)\n+                result_blocks.append(row)\n+            return BlockMatrix(result_blocks)\n \n         return self * other\n \n     def _blockadd(self, other):\n         if (isinstance(other, BlockMatrix)\n                 and self.structurally_equal(other)):\n-            return BlockMatrix(self.blocks + other.blocks)\n+            # Compute block addition manually to preserve MatrixExpr types\n+            m, n = self.blockshape\n+            result_blocks = []\n+            for i in range(m):\n+                row = []\n+                for j in range(n):\n+                    row.append(self.blocks[i, j] + other.blocks[i, j])\n+                result_blocks.append(row)\n+            return BlockMatrix(result_blocks)\n \n         return self + other\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11179", "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..3a462f1c4c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -277,6 +277,7 @@ class Collector:\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-15345", "model_patch": "diff --git a/sympy/printing/mathematica.py b/sympy/printing/mathematica.py\nindex ea7e3a2d94..df3648e8ae 100644\n--- a/sympy/printing/mathematica.py\n+++ b/sympy/printing/mathematica.py\n@@ -100,6 +100,8 @@ def _print_Function(self, expr):\n                 if cond(*expr.args):\n                     return \"%s[%s]\" % (mfunc, self.stringify(expr.args, \", \"))\n         return expr.func.__name__ + \"[%s]\" % self.stringify(expr.args, \", \")\n+    \n+    _print_Expr = _print_Function\n \n     def _print_Integral(self, expr):\n         if len(expr.variables) == 1 and not expr.limits[0][1:]:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-21612", "model_patch": "diff --git a/sympy/parsing/latex/_parse_latex_antlr.py b/sympy/parsing/latex/_parse_latex_antlr.py\nindex 2e4a45ad20..590ffc48f2 100644\n--- a/sympy/parsing/latex/_parse_latex_antlr.py\n+++ b/sympy/parsing/latex/_parse_latex_antlr.py\n@@ -13,11 +13,10 @@\n LaTeXParser = LaTeXLexer = MathErrorListener = None\n \n try:\n-    LaTeXParser = import_module('sympy.parsing.latex._antlr.latexparser',\n-                                import_kwargs={'fromlist': ['LaTeXParser']}).LaTeXParser\n-    LaTeXLexer = import_module('sympy.parsing.latex._antlr.latexlexer',\n-                               import_kwargs={'fromlist': ['LaTeXLexer']}).LaTeXLexer\n-except Exception:\n+    from sympy.parsing.latex._antlr.latexparser import LaTeXParser\n+    from sympy.parsing.latex._antlr.latexlexer import LaTeXLexer\n+except Exception as e:\n+    print(f\"Import error: {e}\")\n     pass\n \n ErrorListener = import_module('antlr4.error.ErrorListener',\n@@ -383,10 +382,7 @@ def convert_frac(frac):\n     expr_top = convert_expr(frac.upper)\n     expr_bot = convert_expr(frac.lower)\n     inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)\n-    if expr_top == 1:\n-        return inverse_denom\n-    else:\n-        return sympy.Mul(expr_top, inverse_denom, evaluate=False)\n+    return sympy.Mul(expr_top, inverse_denom, evaluate=False)\n \n def convert_binom(binom):\n     expr_n = convert_expr(binom.n)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13401", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 28374272f4..c03d15c9ef 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -516,17 +516,31 @@ class Field(RegisterLookupMixin):\n     def __eq__(self, other):\n         # Needed for @total_ordering\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            return (self.creation_counter == other.creation_counter and \n+                    getattr(self, 'model', None) == getattr(other, 'model', None))\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n         if isinstance(other, Field):\n-            return self.creation_counter < other.creation_counter\n+            # Order by creation_counter first for backward compatibility\n+            if self.creation_counter != other.creation_counter:\n+                return self.creation_counter < other.creation_counter\n+            # Then by model\n+            self_model = getattr(self, 'model', None)\n+            other_model = getattr(other, 'model', None)\n+            if self_model is None and other_model is None:\n+                return False\n+            if self_model is None:\n+                return True\n+            if other_model is None:\n+                return False\n+            return (self_model._meta.app_label, self_model._meta.model_name) < \\\n+                   (other_model._meta.app_label, other_model._meta.model_name)\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash(self.creation_counter)\n+        return hash((self.creation_counter, getattr(self, 'model', None)))\n \n     def __deepcopy__(self, memodict):\n         # We don't have to deepcopy very much here, since most things are not\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-13647", "model_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 056d9bc497..4aa75e4d77 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -86,7 +86,7 @@ def entry(i, j):\n                 return self[i, j]\n             elif pos <= j < pos + other.cols:\n                 return other[i, j - pos]\n-            return self[i, j - pos - other.cols]\n+            return self[i, j - other.cols]\n \n         return self._new(self.rows, self.cols + other.cols,\n                          lambda i, j: entry(i, j))\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14017", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..b535df73bf 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -41,7 +41,11 @@ class Q(tree.Node):\n \n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n-            raise TypeError(other)\n+            # Handle objects that can be converted to Q (like Exists)\n+            if getattr(other, 'conditional', False):\n+                other = Q(other)\n+            else:\n+                raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -87,7 +91,11 @@ class Q(tree.Node):\n         args, kwargs = (), {}\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n-            kwargs = {child[0]: child[1]}\n+            # Handle both tuples (lookup, value) and conditional expressions\n+            if isinstance(child, tuple) and len(child) == 2:\n+                kwargs = {child[0]: child[1]}\n+            else:\n+                args = (child,)\n         else:\n             args = tuple(self.children)\n             if self.connector != self.default:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-13480", "model_patch": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\nindex 2a4555d919..5fbb73c786 100644\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -587,7 +587,7 @@ def eval(cls, arg):\n                 x, m = _peeloff_ipi(arg)\n                 if m:\n                     cothm = coth(m)\n-                    if cotm is S.ComplexInfinity:\n+                    if cothm is S.ComplexInfinity:\n                         return coth(x)\n                     else: # cothm == 0\n                         return tanh(x)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-13496", "model_patch": "diff --git a/sklearn/ensemble/iforest.py b/sklearn/ensemble/iforest.py\nindex 8a1bd3625..f42c80532 100644\n--- a/sklearn/ensemble/iforest.py\n+++ b/sklearn/ensemble/iforest.py\n@@ -120,6 +120,11 @@ class IsolationForest(BaseBagging, OutlierMixin):\n     verbose : int, optional (default=0)\n         Controls the verbosity of the tree building process.\n \n+    warm_start : bool, optional (default=False)\n+        When set to ``True``, reuse the solution of the previous call to fit\n+        and add more estimators to the ensemble, otherwise, just fit a whole\n+        new forest. See :term:`the Glossary <warm_start>`.\n+\n \n     Attributes\n     ----------\n@@ -173,7 +178,8 @@ class IsolationForest(BaseBagging, OutlierMixin):\n                  n_jobs=None,\n                  behaviour='old',\n                  random_state=None,\n-                 verbose=0):\n+                 verbose=0,\n+                 warm_start=False):\n         super().__init__(\n             base_estimator=ExtraTreeRegressor(\n                 max_features=1,\n@@ -187,7 +193,8 @@ class IsolationForest(BaseBagging, OutlierMixin):\n             max_features=max_features,\n             n_jobs=n_jobs,\n             random_state=random_state,\n-            verbose=verbose)\n+            verbose=verbose,\n+            warm_start=warm_start)\n \n         self.behaviour = behaviour\n         self.contamination = contamination\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13590", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..0413415fc5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1077,10 +1077,13 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n-                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n-                for sub_value in value\n-            )\n+            resolved = [self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n+                       for sub_value in value]\n+            # Handle named tuples which require unpacking\n+            if hasattr(type(value), '_fields'):  # Named tuple\n+                return type(value)(*resolved)\n+            else:\n+                return type(value)(resolved)\n         return value\n \n     def solve_lookup_type(self, lookup):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-21847", "model_patch": "diff --git a/sympy/polys/monomials.py b/sympy/polys/monomials.py\nindex 0e84403307..d2cd3451e5 100644\n--- a/sympy/polys/monomials.py\n+++ b/sympy/polys/monomials.py\n@@ -127,7 +127,7 @@ def itermonomials(variables, max_degrees, min_degrees=None):\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\n-                if max(powers.values()) >= min_degree:\n+                if sum(powers.values()) >= min_degree:\n                     monomials_list_comm.append(Mul(*item))\n             yield from set(monomials_list_comm)\n         else:\n@@ -139,7 +139,7 @@ def itermonomials(variables, max_degrees, min_degrees=None):\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\n-                if max(powers.values()) >= min_degree:\n+                if sum(powers.values()) >= min_degree:\n                     monomials_list_non_comm.append(Mul(*item))\n             yield from set(monomials_list_non_comm)\n     else:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14915", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5dcf923c12..bc7e6959e7 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1171,6 +1171,9 @@ class ModelChoiceIteratorValue:\n             other = other.value\n         return self.value == other\n \n+    def __hash__(self):\n+        return hash(self.value)\n+\n \n class ModelChoiceIterator:\n     def __init__(self, field):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-14983", "model_patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex c49a3ce6a..fe5b3c552 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -1063,7 +1063,7 @@ class LeavePGroupsOut(BaseCrossValidator):\n         return super().split(X, y, groups)\n \n \n-class _RepeatedSplits(metaclass=ABCMeta):\n+class _RepeatedSplits(BaseCrossValidator):\n     \"\"\"Repeated splits for an arbitrary randomized CV splitter.\n \n     Repeats splits for cross-validators n times with different randomization\n@@ -1213,6 +1213,7 @@ class RepeatedKFold(_RepeatedSplits):\n     RepeatedStratifiedKFold: Repeats Stratified K-Fold n times.\n     \"\"\"\n     def __init__(self, n_splits=5, n_repeats=10, random_state=None):\n+        self.n_splits = n_splits\n         super().__init__(\n             KFold, n_repeats, random_state, n_splits=n_splits)\n \n@@ -1266,6 +1267,7 @@ class RepeatedStratifiedKFold(_RepeatedSplits):\n     RepeatedKFold: Repeats K-Fold n times.\n     \"\"\"\n     def __init__(self, n_splits=5, n_repeats=10, random_state=None):\n+        self.n_splits = n_splits\n         super().__init__(\n             StratifiedKFold, n_repeats, random_state, n_splits=n_splits)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "astropy__astropy-12907", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..45bea36085 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-23262", "model_patch": "diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex da67263b19..93f6dd1e34 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -961,7 +961,11 @@ def _recursive_to_string(doprint, arg):\n             left, right = \"()\"\n         else:\n             raise NotImplementedError(\"unhandled type: %s, %s\" % (type(arg), arg))\n-        return left +', '.join(_recursive_to_string(doprint, e) for e in arg) + right\n+        elements = ', '.join(_recursive_to_string(doprint, e) for e in arg)\n+        # Handle single-element tuples\n+        if isinstance(arg, tuple) and len(arg) == 1:\n+            elements += ','\n+        return left + elements + right\n     elif isinstance(arg, str):\n         return arg\n     else:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-24066", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex 3daf84c108..d77a0b6c9c 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -175,7 +175,7 @@ def _collect_factor_and_dimension(self, expr):\n             for addend in expr.args[1:]:\n                 addend_factor, addend_dim = \\\n                     self._collect_factor_and_dimension(addend)\n-                if dim != addend_dim:\n+                if not self.get_dimension_system().equivalent_dims(dim, addend_dim):\n                     raise ValueError(\n                         'Dimension of \"{}\" is {}, '\n                         'but it should be {}'.format(\n@@ -192,6 +192,10 @@ def _collect_factor_and_dimension(self, expr):\n         elif isinstance(expr, Function):\n             fds = [self._collect_factor_and_dimension(\n                 arg) for arg in expr.args]\n+            # For functions like exp, sin, cos, log, etc., if all arguments are dimensionless,\n+            # the result should be Dimension(1), consistent with get_dimensional_expr\n+            if all(self.get_dimension_system().is_dimensionless(d[1]) for d in fds):\n+                return expr.func(*(f[0] for f in fds)), Dimension(1)\n             return (expr.func(*(f[0] for f in fds)),\n                     *(d[1] for d in fds))\n         elif isinstance(expr, Dimension):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-24970", "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..6d05c535f5 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -725,6 +725,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        else:\n+            # Ensure we can represent _i_over, _i_under, _i_bad\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-24149", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..91040d6bfe 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1738,6 +1738,8 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n                 pass\n             raise RuntimeError(\"matplotlib does not support generators \"\n                                \"as input\")\n+        # Note: if obj is empty, this will raise StopIteration,\n+        # which is expected by some callers (e.g., units.py)\n         return next(iter(obj))\n     elif isinstance(obj, np.flatiter):\n         # TODO do the finite filtering on this\n@@ -1746,7 +1748,17 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # If ALL values are non-finite, just return the first one\n+            # But if obj is EMPTY, let StopIteration propagate\n+            try:\n+                first = next(iter(obj))\n+            except StopIteration:\n+                # obj is empty, let StopIteration propagate\n+                raise\n+            return first\n \n \n def sanitize_sequence(data):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-16139", "model_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex b3cfc6723c..24660a5469 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -163,7 +163,10 @@ class UserChangeForm(forms.ModelForm):\n         super().__init__(*args, **kwargs)\n         password = self.fields.get(\"password\")\n         if password:\n-            password.help_text = password.help_text.format(\"../password/\")\n+            if self.instance.pk:\n+                password.help_text = password.help_text.format(f\"../../{self.instance.pk}/password/\")\n+            else:\n+                password.help_text = password.help_text.format(\"../password/\")\n         user_permissions = self.fields.get(\"user_permissions\")\n         if user_permissions:\n             user_permissions.queryset = user_permissions.queryset.select_related(\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "pytest-dev__pytest-7490", "model_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..d015d995a 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -261,7 +261,18 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n     rep = outcome.get_result()\n-    xfailed = item._store.get(xfailed_key, None)\n+    # Re-evaluate xfail marks in the call phase only, in case they were added dynamically during the test\n+    if call.when == \"call\":\n+        # Use the stored value as fallback in case of errors\n+        xfailed = item._store.get(xfailed_key, None)\n+        try:\n+            xfailed = evaluate_xfail_marks(item)\n+            item._store[xfailed_key] = xfailed\n+        except Exception:\n+            # Keep the stored value if evaluation fails\n+            pass\n+    else:\n+        xfailed = item._store.get(xfailed_key, None)\n     # unittest special case, see setting of unexpectedsuccess_key\n     if unexpectedsuccess_key in item._store and rep.when == \"call\":\n         reason = item._store[unexpectedsuccess_key]\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-12419", "model_patch": "diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py\nindex 372487664c..6d90ac1d06 100644\n--- a/sympy/concrete/summations.py\n+++ b/sympy/concrete/summations.py\n@@ -866,6 +866,41 @@ def eval_sum(f, limits):\n                     return None\n                 newargs.append((newexpr, arg.cond))\n             return f.func(*newargs)\n+        else:\n+            # If it's 1 when i is in [a, b] and 0 otherwise, sum is (b - a + 1)*expr\n+            if len(f.args) == 2 and f.args[1][1] == True:\n+                cond = f.args[0][1]\n+                expr = f.args[0][0]\n+                # Check if condition is i in [a, b]\n+                from sympy.logic.boolalg import And\n+                if isinstance(cond, And) and len(cond.args) == 2:\n+                    # Could be (i >= a) & (i <= b) or (i <= b) & (i >= a)\n+                    geq = None\n+                    leq = None\n+                    for c in cond.args:\n+                        from sympy.core.relational import GreaterThan, LessThan, StrictGreaterThan, StrictLessThan\n+                        if isinstance(c, GreaterThan):\n+                            if c.args[0] == i:\n+                                geq = c.args[1]\n+                            elif c.args[1] == i:\n+                                geq = c.args[0]\n+                        elif isinstance(c, LessThan):\n+                            if c.args[0] == i:\n+                                leq = c.args[1]\n+                            elif c.args[1] == i:\n+                                geq = c.args[0]\n+                        elif isinstance(c, StrictGreaterThan):\n+                            if c.args[0] == i:\n+                                geq = c.args[1] + 1\n+                            elif c.args[1] == i:\n+                                geq = c.args[0] + 1\n+                        elif isinstance(c, StrictLessThan):\n+                            if c.args[0] == i:\n+                                leq = c.args[1] - 1\n+                            elif c.args[1] == i:\n+                                leq = c.args[0] - 1\n+                    if geq == a and leq == b:\n+                        return expr * (b - a + 1)\n \n     if f.has(KroneckerDelta) and _has_simple_delta(f, limits[0]):\n         return deltasummation(f, limits)\ndiff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e..cd6770d69b 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -476,10 +476,8 @@ def conjugate(self):\n         return self\n \n     def _entry(self, i, j):\n-        if i == j:\n-            return S.One\n-        else:\n-            return S.Zero\n+        from sympy import KroneckerDelta\n+        return KroneckerDelta(i, j)\n \n     def _eval_determinant(self):\n         return S.One\ndiff --git a/sympy/matrices/expressions/matmul.py b/sympy/matrices/expressions/matmul.py\nindex 79f3035f92..bdf57c3660 100644\n--- a/sympy/matrices/expressions/matmul.py\n+++ b/sympy/matrices/expressions/matmul.py\n@@ -284,7 +284,11 @@ def refine_MatMul(expr, assumptions):\n             last = arg\n     newargs.append(last)\n \n-    return MatMul(*newargs)\n+    result = MatMul(*newargs)\n+    # If we just have a single Identity, return it directly\n+    if len(newargs) == 1 and isinstance(newargs[0], Identity):\n+        return newargs[0]\n+    return result\n \n \n handlers_dict['MatMul'] = refine_MatMul\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "astropy__astropy-14365", "model_patch": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\nindex 83a4f004aa..0d16ef671d 100644\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -67,7 +67,7 @@ def _line_type(line, delimiter=None):\n         sep = r\"\\s+\"\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n-    _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n+    _type_re = rf\"(?i)^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n     _line_type_re = re.compile(_type_re)\n     line = line.strip()\n     if not line:\n@@ -306,7 +306,7 @@ def _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n \n             values = []\n             for v in line.split(delimiter):\n-                if v == \"NO\":\n+                if v.upper() == \"NO\":\n                     values.append(np.ma.masked)\n                 else:\n                     # Understand if number is int or float\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-15252", "model_patch": "diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\nindex 1a37c6b7d0..86457f7d36 100644\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -1,5 +1,5 @@\n from django.apps.registry import Apps\n-from django.db import DatabaseError, models\n+from django.db import DatabaseError, models, router\n from django.utils.functional import classproperty\n from django.utils.timezone import now\n \n@@ -58,6 +58,9 @@ class MigrationRecorder:\n \n     def ensure_schema(self):\n         \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate_model(self.connection.alias, self.Migration):\n+            return\n         # If the table's there, that's fine - we've never changed its schema\n         # in the codebase.\n         if self.has_table():\n@@ -74,6 +77,9 @@ class MigrationRecorder:\n         Return a dict mapping (app_name, migration_name) to Migration instances\n         for all applied migrations.\n         \"\"\"\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate_model(self.connection.alias, self.Migration):\n+            return {}\n         if self.has_table():\n             return {(migration.app, migration.name): migration for migration in self.migration_qs}\n         else:\n@@ -83,14 +89,23 @@ class MigrationRecorder:\n \n     def record_applied(self, app, name):\n         \"\"\"Record that a migration was applied.\"\"\"\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate_model(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.migration_qs.create(app=app, name=name)\n \n     def record_unapplied(self, app, name):\n         \"\"\"Record that a migration was unapplied.\"\"\"\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate_model(self.connection.alias, self.Migration):\n+            return\n         self.ensure_schema()\n         self.migration_qs.filter(app=app, name=name).delete()\n \n     def flush(self):\n         \"\"\"Delete all migration records. Useful for testing migrations.\"\"\"\n+        # Check if migrations are allowed on this database\n+        if not router.allow_migrate_model(self.connection.alias, self.Migration):\n+            return\n         self.migration_qs.all().delete()\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-20154", "model_patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\nindex dd36dea304..25938299e0 100644\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -1738,19 +1738,11 @@ def partitions(n, m=None, k=None, size=False):\n     {2: 1, 4: 1}\n     {3: 2}\n \n-    Note that the _same_ dictionary object is returned each time.\n-    This is for speed:  generating each partition goes quickly,\n-    taking constant time, independent of n.\n+    Each partition is returned as a new dictionary object.\n \n     >>> [p for p in partitions(6, k=2)]\n-    [{1: 6}, {1: 6}, {1: 6}, {1: 6}]\n-\n-    If you want to build a list of the returned dictionaries then\n-    make a copy of them:\n-\n-    >>> [p.copy() for p in partitions(6, k=2)]  # doctest: +SKIP\n     [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]\n-    >>> [(M, p.copy()) for M, p in partitions(6, k=2, size=True)]  # doctest: +SKIP\n+    >>> [(M, p) for M, p in partitions(6, k=2, size=True)]  # doctest: +SKIP\n     [(3, {2: 3}), (4, {1: 2, 2: 2}), (5, {1: 4, 2: 1}), (6, {1: 6})]\n \n     References\n@@ -1802,9 +1794,9 @@ def partitions(n, m=None, k=None, size=False):\n         keys.append(r)\n     room = m - q - bool(r)\n     if size:\n-        yield sum(ms.values()), ms\n+        yield sum(ms.values()), ms.copy()\n     else:\n-        yield ms\n+        yield ms.copy()\n \n     while keys != [1]:\n         # Reuse any 1's.\n@@ -1842,9 +1834,9 @@ def partitions(n, m=None, k=None, size=False):\n             break\n         room -= need\n         if size:\n-            yield sum(ms.values()), ms\n+            yield sum(ms.values()), ms.copy()\n         else:\n-            yield ms\n+            yield ms.copy()\n \n \n def ordered_partitions(n, m=None, sort=True):\n@@ -1888,13 +1880,9 @@ def ordered_partitions(n, m=None, sort=True):\n     [1, 4]\n     [2, 3]\n \n-    When ``m`` is given, a given list objects will be used more than\n-    once for speed reasons so you will not see the correct partitions\n-    unless you make a copy of each as it is generated:\n+    Each partition is returned as a new list object.\n \n     >>> [p for p in ordered_partitions(7, 3)]\n-    [[1, 1, 1], [1, 1, 1], [1, 1, 1], [2, 2, 2]]\n-    >>> [list(p) for p in ordered_partitions(7, 3)]\n     [[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]]\n \n     When ``n`` is a multiple of ``m``, the elements are still sorted\n@@ -1968,18 +1956,18 @@ def ordered_partitions(n, m=None, sort=True):\n             x = n - b*m\n             if not x:\n                 if sort:\n-                    yield a\n+                    yield a.copy()\n             elif not sort and x <= m:\n                 for ax in ordered_partitions(x, sort=False):\n                     mi = len(ax)\n                     a[-mi:] = [i + b for i in ax]\n-                    yield a\n+                    yield a.copy()\n                     a[-mi:] = [b]*mi\n             else:\n                 for mi in range(1, m):\n                     for ax in ordered_partitions(x, mi, sort=True):\n                         a[-mi:] = [i + b for i in ax]\n-                        yield a\n+                        yield a.copy()\n                         a[-mi:] = [b]*mi\n \n \n@@ -2021,7 +2009,7 @@ def binary_partitions(n):\n \n     last_num = len(partition) - 1 - (n & 1)\n     while last_num >= 0:\n-        yield partition\n+        yield partition.copy()\n         if partition[last_num] == 2:\n             partition[last_num] = 1\n             partition.append(1)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-25311", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..3a04e2b5b0 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1513,26 +1513,48 @@ class DraggableBase:\n             self.canvas.callbacks._connect_picklable(\n                 'button_release_event', self.on_release),\n         ]\n+    \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Canvas is not pickleable, remove it\n+        if 'canvas' in state:\n+            del state['canvas']\n+        # Also remove connection IDs as they're invalid after unpickling\n+        if 'cids' in state:\n+            del state['cids']\n+        if '_c1' in state:\n+            del state['_c1']\n+        if 'background' in state:\n+            del state['background']\n+        return state\n+    \n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Don't connect callbacks now - canvas might not exist yet\n+        # We'll connect when needed in _check_still_parented or on_pick\n+        self.canvas = None\n+        self.cids = []\n \n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n-            if self._use_blit:\n-                self.canvas.restore_region(self.background)\n-                self.ref_artist.draw(\n-                    self.ref_artist.figure._get_renderer())\n-                self.canvas.blit()\n-            else:\n-                self.canvas.draw()\n+            if self.canvas:\n+                if self._use_blit:\n+                    self.canvas.restore_region(self.background)\n+                    self.ref_artist.draw(\n+                        self.ref_artist.figure._get_renderer())\n+                    self.canvas.blit()\n+                else:\n+                    self.canvas.draw()\n \n     def on_pick(self, evt):\n         if self._check_still_parented() and evt.artist == self.ref_artist:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n-            if self._use_blit:\n+            if self._use_blit and self.canvas:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n                 self.background = \\\n@@ -1540,15 +1562,17 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if self.canvas:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n             self.save_offset()\n \n     def on_release(self, event):\n         if self._check_still_parented() and self.got_artist:\n             self.finalize_offset()\n             self.got_artist = False\n-            self.canvas.mpl_disconnect(self._c1)\n+            if self.canvas:\n+                self.canvas.mpl_disconnect(self._c1)\n \n             if self._use_blit:\n                 self.ref_artist.set_animated(False)\n@@ -1558,18 +1582,29 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Reconnect if needed (e.g., after unpickling)\n+            if self.canvas is None and hasattr(self.ref_artist.figure, 'canvas'):\n+                self.canvas = self.ref_artist.figure.canvas\n+                if not self.cids and hasattr(self.canvas, 'callbacks'):\n+                    self.cids = [\n+                        self.canvas.callbacks._connect_picklable(\n+                            'pick_event', self.on_pick),\n+                        self.canvas.callbacks._connect_picklable(\n+                            'button_release_event', self.on_release),\n+                    ]\n             return True\n \n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if self.canvas:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n \n     def save_offset(self):\n         pass\n@@ -1588,10 +1623,11 @@ class DraggableOffsetBox(DraggableBase):\n \n     def save_offset(self):\n         offsetbox = self.offsetbox\n-        renderer = offsetbox.figure._get_renderer()\n-        offset = offsetbox.get_offset(offsetbox.get_bbox(renderer), renderer)\n-        self.offsetbox_x, self.offsetbox_y = offset\n-        self.offsetbox.set_offset(offset)\n+        if offsetbox.figure:\n+            renderer = offsetbox.figure._get_renderer()\n+            offset = offsetbox.get_offset(offsetbox.get_bbox(renderer), renderer)\n+            self.offsetbox_x, self.offsetbox_y = offset\n+            self.offsetbox.set_offset(offset)\n \n     def update_offset(self, dx, dy):\n         loc_in_canvas = self.offsetbox_x + dx, self.offsetbox_y + dy\n@@ -1599,11 +1635,13 @@ class DraggableOffsetBox(DraggableBase):\n \n     def get_loc_in_canvas(self):\n         offsetbox = self.offsetbox\n-        renderer = offsetbox.figure._get_renderer()\n-        bbox = offsetbox.get_bbox(renderer)\n-        ox, oy = offsetbox._offset\n-        loc_in_canvas = (ox + bbox.x0, oy + bbox.y0)\n-        return loc_in_canvas\n+        if offsetbox.figure:\n+            renderer = offsetbox.figure._get_renderer()\n+            bbox = offsetbox.get_bbox(renderer)\n+            ox, oy = offsetbox._offset\n+            loc_in_canvas = (ox + bbox.x0, oy + bbox.y0)\n+            return loc_in_canvas\n+        return (0, 0)\n \n \n class DraggableAnnotation(DraggableBase):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-25332", "model_patch": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..ff38f244a3 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -846,6 +846,28 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        # Convert weakrefs to actual objects for pickling\n+        # First, clean to remove dead references\n+        self.clean()\n+        # Return list of groups (each group is a list of objects)\n+        groups = []\n+        for group in self:\n+            if group:  # Only include non-empty groups\n+                groups.append(group)\n+        return groups\n+\n+    def __setstate__(self, state):\n+        # Reconstruct from groups of objects\n+        self._mapping = {}\n+        for group in state:\n+            if len(group) > 0:\n+                # Create refs for all objects in the group\n+                refs = [weakref.ref(obj) for obj in group]\n+                # Point all refs to the same list\n+                for ref in refs:\n+                    self._mapping[ref] = refs\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14580", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex e19c881cda..072a2efc14 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -273,7 +273,7 @@ class TupleSerializer(BaseSequenceSerializer):\n class TypeSerializer(BaseSerializer):\n     def serialize(self):\n         special_cases = [\n-            (models.Model, \"models.Model\", []),\n+            (models.Model, \"models.Model\", [\"from django.db import models\"]),\n             (type(None), 'type(None)', []),\n         ]\n         for case, string, imports in special_cases:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-12125", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 7d226955d5..e953cb7ff4 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -95,7 +95,21 @@ class DeconstructableSerializer(BaseSerializer):\n             imports = {\"from django.db import models\"}\n             name = \"models.%s\" % name\n         else:\n-            imports = {\"import %s\" % module}\n+            # Find the actual module by checking sys.modules\n+            import sys\n+            parts = module.split(\".\")\n+            actual_module = None\n+            for i in range(len(parts), 0, -1):\n+                candidate = \".\".join(parts[:i])\n+                if candidate in sys.modules:\n+                    actual_module = candidate\n+                    break\n+            \n+            if actual_module is None:\n+                # Fallback - just use the whole prefix as module\n+                imports = {\"import %s\" % module}\n+            else:\n+                imports = {\"import %s\" % actual_module}\n             name = path\n         return name, imports\n \n@@ -143,7 +157,7 @@ class FunctionTypeSerializer(BaseSerializer):\n         if getattr(self.value, \"__self__\", None) and isinstance(self.value.__self__, type):\n             klass = self.value.__self__\n             module = klass.__module__\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\"import %s\" % module}\n+            return \"%s.%s.%s\" % (module, klass.__qualname__, self.value.__name__), {\"import %s\" % module}\n         # Further error checking\n         if self.value.__name__ == '<lambda>':\n             raise ValueError(\"Cannot serialize function: lambda\")\n@@ -269,7 +283,7 @@ class TypeSerializer(BaseSerializer):\n             if module == builtins.__name__:\n                 return self.value.__name__, set()\n             else:\n-                return \"%s.%s\" % (module, self.value.__name__), {\"import %s\" % module}\n+                return \"%s.%s\" % (module, self.value.__qualname__), {\"import %s\" % module}\n \n \n class UUIDSerializer(BaseSerializer):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13033", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..edc283d94c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,7 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != pieces[-1] and pieces[-1] != 'pk':\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-23314", "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 9db44b7994..74b7897165 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -387,6 +387,10 @@ class Axes3D(Axes):\n \n     @martist.allow_rasterization\n     def draw(self, renderer):\n+        if renderer is None:\n+            raise RuntimeError('No renderer defined')\n+        if not self.get_visible():\n+            return\n         self._unstale_viewLim()\n \n         # draw the background patch\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "astropy__astropy-14182", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8efb..d3ba6ef8cb 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -27,7 +27,7 @@ class SimpleRSTHeader(FixedWidthHeader):\n \n \n class SimpleRSTData(FixedWidthData):\n-    start_line = 3\n+    start_line = None  # Will be set by parent based on header_rows length\n     end_line = -1\n     splitter_class = FixedWidthTwoLineDataSplitter\n \n@@ -57,10 +57,21 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n+        # RST format has a separator line AFTER the header rows\n+        # So data starts at: header.start_line + len(header_rows) + 1\n+        # because: position_line (1 line) + header_rows (N lines) + separator (1 line)\n+        self.data.start_line = self.header.start_line + len(self.header.header_rows) + 1\n \n     def write(self, lines):\n         lines = super().write(lines)\n-        lines = [lines[1]] + lines + [lines[1]]\n+        # In super().write(), if position_line is not None, it adds a separator AFTER headers\n+        # But RST format needs separator BEFORE headers too, and at the end\n+        # Find the auto-added separator line (should be after header rows)\n+        header_rows = getattr(self.header, 'header_rows', ['name'])\n+        separator_pos = len(header_rows)  # separator is added after header rows\n+        if separator_pos < len(lines):\n+            separator_line = lines[separator_pos]\n+            lines = [separator_line] + lines + [separator_line]\n         return lines\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13933", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 422bc5d178..78a77fc3db 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1188,7 +1188,7 @@ class ModelChoiceField(ChoiceField):\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n-        'invalid_choice': _('Select a valid choice. That choice is not one of'\n+        'invalid_choice': _('Select a valid choice. %(value)s is not one of'\n                             ' the available choices.'),\n     }\n     iterator = ModelChoiceIterator\n@@ -1284,7 +1284,11 @@ class ModelChoiceField(ChoiceField):\n                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n+            raise ValidationError(\n+                self.error_messages['invalid_choice'], \n+                code='invalid_choice',\n+                params={'value': value}\n+            )\n         return value\n \n     def validate(self, value):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sphinx-doc__sphinx-8595", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex d85d79617..c9f90acca 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1074,7 +1074,7 @@ class ModuleDocumenter(Documenter):\n     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         members = self.get_module_members()\n         if want_all:\n-            if not self.__all__:\n+            if self.__all__ is None:\n                 # for implicit module members, check __module__ to avoid\n                 # documenting imported objects\n                 return True, list(members.values())\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "pylint-dev__pylint-7080", "model_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 5cacc0371..4ac5a1af7 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -7,6 +7,7 @@ from __future__ import annotations\n import os\n import sys\n from collections.abc import Sequence\n+from pathlib import Path\n from re import Pattern\n \n from astroid import modutils\n@@ -53,10 +54,12 @@ def _is_ignored_file(\n     ignore_list_paths_re: list[Pattern[str]],\n ) -> bool:\n     basename = os.path.basename(element)\n+    # Normalize path separators for path pattern matching\n+    normalized_element = str(Path(element).as_posix())\n     return (\n         basename in ignore_list\n         or _is_in_ignore_list_re(basename, ignore_list_re)\n-        or _is_in_ignore_list_re(element, ignore_list_paths_re)\n+        or _is_in_ignore_list_re(normalized_element, ignore_list_paths_re)\n     )\n \n \n@@ -142,7 +145,7 @@ def expand_modules(\n                     continue\n                 if _is_in_ignore_list_re(\n                     os.path.basename(subfilepath), ignore_list_re\n-                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):\n+                ) or _is_in_ignore_list_re(str(Path(subfilepath).as_posix()), ignore_list_paths_re):\n                     continue\n \n                 modpath = _modpath_from_file(\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11815", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..a024bc70fd 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,7 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        return \"%s.%s[%s]\" % (module, enum_class.__name__, repr(self.value.name)), {'import %s' % module}\n \n \n class FloatSerializer(BaseSimpleSerializer):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-17087", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex d88cda6e20..06657ebaab 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -168,7 +168,7 @@ class FunctionTypeSerializer(BaseSerializer):\n         ):\n             klass = self.value.__self__\n             module = klass.__module__\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\n+            return \"%s.%s.%s\" % (module, klass.__qualname__, self.value.__name__), {\n                 \"import %s\" % module\n             }\n         # Further error checking\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-15851", "model_patch": "diff --git a/django/db/backends/mysql/client.py b/django/db/backends/mysql/client.py\nindex 6aa11b2e1f..3d8c1bf1ad 100644\n--- a/django/db/backends/mysql/client.py\n+++ b/django/db/backends/mysql/client.py\n@@ -56,9 +56,9 @@ class DatabaseClient(BaseDatabaseClient):\n             args += [\"--ssl-key=%s\" % client_key]\n         if charset:\n             args += [\"--default-character-set=%s\" % charset]\n+        args.extend(parameters)\n         if database:\n             args += [database]\n-        args.extend(parameters)\n         return args, env\n \n     def runshell(self, parameters):\ndiff --git a/django/db/backends/oracle/client.py b/django/db/backends/oracle/client.py\nindex 365b116046..f05062017d 100644\n--- a/django/db/backends/oracle/client.py\n+++ b/django/db/backends/oracle/client.py\n@@ -19,9 +19,10 @@ class DatabaseClient(BaseDatabaseClient):\n \n     @classmethod\n     def settings_to_cmd_args_env(cls, settings_dict, parameters):\n-        args = [cls.executable_name, \"-L\", cls.connect_string(settings_dict)]\n+        args = [cls.executable_name, \"-L\"]\n+        args.extend(parameters)\n+        args.append(cls.connect_string(settings_dict))\n         wrapper_path = shutil.which(cls.wrapper_name)\n         if wrapper_path:\n-            args = [wrapper_path, *args]\n-        args.extend(parameters)\n+            args = [wrapper_path] + args\n         return args, None\ndiff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 4c9bd63546..3b5ddafaca 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -32,9 +32,9 @@ class DatabaseClient(BaseDatabaseClient):\n             args += [\"-h\", host]\n         if port:\n             args += [\"-p\", str(port)]\n+        args.extend(parameters)\n         if dbname:\n             args += [dbname]\n-        args.extend(parameters)\n \n         env = {}\n         if passwd:\ndiff --git a/django/db/backends/sqlite3/client.py b/django/db/backends/sqlite3/client.py\nindex 7cee35dc81..3f04766cdd 100644\n--- a/django/db/backends/sqlite3/client.py\n+++ b/django/db/backends/sqlite3/client.py\n@@ -6,5 +6,5 @@ class DatabaseClient(BaseDatabaseClient):\n \n     @classmethod\n     def settings_to_cmd_args_env(cls, settings_dict, parameters):\n-        args = [cls.executable_name, settings_dict[\"NAME\"], *parameters]\n+        args = [cls.executable_name, *parameters, settings_dict[\"NAME\"]]\n         return args, None\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14672", "model_patch": "diff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py\nindex ccc2223a5f..65950590e2 100644\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -310,7 +310,7 @@ class ManyToManyRel(ForeignObjectRel):\n     def identity(self):\n         return super().identity + (\n             self.through,\n-            self.through_fields,\n+            make_hashable(self.through_fields),\n             self.db_constraint,\n         )\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14752", "model_patch": "diff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py\nindex 3903e4c98c..9ac277e779 100644\n--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -26,12 +26,18 @@ class AutocompleteJsonView(BaseListView):\n         context = self.get_context_data()\n         return JsonResponse({\n             'results': [\n-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n-                for obj in context['object_list']\n+                self.serialize_result(obj, to_field_name) for obj in context['object_list']\n             ],\n             'pagination': {'more': context['page_obj'].has_next()},\n         })\n \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"\n+        Return a dictionary representation of the result object.\n+        Override this method to add extra fields to autocomplete results.\n+        \"\"\"\n+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+\n     def get_paginator(self, *args, **kwargs):\n         \"\"\"Use the ModelAdmin's paginator.\"\"\"\n         return self.model_admin.get_paginator(self.request, *args, **kwargs)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11099", "model_patch": "diff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex b4878cfd45..1304f20a60 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,7 +17,7 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14534", "model_patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 2ff8b0ee26..59987ee101 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -277,7 +277,7 @@ class BoundWidget:\n \n     @property\n     def id_for_label(self):\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+        return self.data['attrs'].get('id', 'id_%s_%s' % (self.data['name'], self.data['index']))\n \n     @property\n     def choice_label(self):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-12481", "model_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a478..1483dc8bb8 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -894,14 +894,17 @@ def __new__(cls, *args, **kwargs):\n         # for convenience in case one wants to enter permutations where\n         # counting starts from 1.\n \n-        temp = flatten(args)\n-        if has_dups(temp):\n-            if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n-            else:\n+        if is_cycle:\n+            # Check for duplicates within EACH cycle, not across cycles\n+            for cycle in args:\n+                if has_dups(cycle):\n+                    raise ValueError('All elements must be unique within a cycle.')\n+            temp = set(flatten(args))\n+        else:\n+            temp = flatten(args)\n+            if has_dups(temp):\n                 raise ValueError('there were repeated elements.')\n-        temp = set(temp)\n+            temp = set(temp)\n \n         if not is_cycle and \\\n                 any(i not in temp for i in range(len(temp))):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..d98203c2 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1961,7 +1961,11 @@ class DataArray(AbstractArray, DataWithCoords):\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            selected = self.sel({variable_dim: k})\n+            # Drop the stacked dimension if it still exists as a coordinate\n+            if dim in selected.coords:\n+                selected = selected.drop_vars(dim)\n+            data_dict[k] = selected.squeeze(drop=True)\n \n         # unstacked dataset\n         return Dataset(data_dict)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13925", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 4038859cfa..fafd950786 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1302,6 +1302,17 @@ class Model(metaclass=ModelBase):\n             not settings.is_overridden('DEFAULT_AUTO_FIELD') and\n             not cls._meta.app_config._is_default_auto_field_overridden\n         ):\n+            # If this is a multi-table inheritance model and the pk is a\n+            # parent link, check if any ancestor's pk is manually defined\n+            current = cls\n+            while (current._meta.pk.one_to_one and \n+                   hasattr(current._meta.pk, 'remote_field') and\n+                   current._meta.pk.remote_field and\n+                   current._meta.pk.remote_field.parent_link):\n+                parent_model = current._meta.pk.remote_field.model\n+                if parent_model._meta.pk and not parent_model._meta.pk.auto_created:\n+                    return []\n+                current = parent_model\n             return [\n                 checks.Warning(\n                     f\"Auto-created primary key used when not defining a \"\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-22714", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 73c20334d0..fbe5804d77 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -152,7 +152,7 @@ def __new__(cls, *args, **kwargs):\n                         'warn' or 'ignore'.'''))\n         if any(coords[dim:]):\n             raise ValueError('Nonzero coordinates cannot be removed.')\n-        if any(a.is_number and im(a) for a in coords):\n+        if any(a.is_number and not a.is_real for a in coords):\n             raise ValueError('Imaginary coordinates are not permitted.')\n         if not all(isinstance(a, Expr) for a in coords):\n             raise TypeError('Coordinates must be valid SymPy expressions.')\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14855", "model_patch": "diff --git a/django/contrib/admin/helpers.py b/django/contrib/admin/helpers.py\nindex dd154f72ee..ba8c3463a0 100644\n--- a/django/contrib/admin/helpers.py\n+++ b/django/contrib/admin/helpers.py\n@@ -209,7 +209,11 @@ class AdminReadonlyField:\n             remote_field.model._meta.model_name,\n         )\n         try:\n-            url = reverse(url_name, args=[quote(remote_obj.pk)])\n+            url = reverse(\n+                url_name,\n+                args=[quote(remote_obj.pk)],\n+                current_app=self.model_admin.admin_site.name\n+            )\n             return format_html('<a href=\"{}\">{}</a>', url, remote_obj)\n         except NoReverseMatch:\n             return str(remote_obj)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-16595", "model_patch": "diff --git a/django/db/migrations/operations/fields.py b/django/db/migrations/operations/fields.py\nindex cd3aab43ad..7765d310f0 100644\n--- a/django/db/migrations/operations/fields.py\n+++ b/django/db/migrations/operations/fields.py\n@@ -247,7 +247,7 @@ class AlterField(FieldOperation):\n         return \"alter_%s_%s\" % (self.model_name_lower, self.name_lower)\n \n     def reduce(self, operation, app_label):\n-        if isinstance(operation, RemoveField) and self.is_same_field_operation(\n+        if isinstance(operation, (RemoveField, AlterField)) and self.is_same_field_operation(\n             operation\n         ):\n             return [operation]\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-10297", "model_patch": "diff --git a/sklearn/linear_model/ridge.py b/sklearn/linear_model/ridge.py\nindex 911c74ae3..5325ba155 100644\n--- a/sklearn/linear_model/ridge.py\n+++ b/sklearn/linear_model/ridge.py\n@@ -1301,6 +1301,26 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n         weights inversely proportional to class frequencies in the input data\n         as ``n_samples / (n_classes * np.bincount(y))``\n \n+    gcv_mode : {None, 'auto', 'svd', eigen'}, optional\n+        Flag indicating which strategy to use when performing\n+        Generalized Cross-Validation. Options are::\n+\n+            'auto' : use svd if n_samples > n_features or when X is a sparse\n+                     matrix, otherwise use eigen\n+            'svd' : force computation via singular value decomposition of X\n+                    (does not work for sparse matrices)\n+            'eigen' : force computation via eigendecomposition of X^T X\n+\n+        The 'auto' mode is the default and is intended to pick the cheaper\n+        option of the two depending upon the shape and format of the training\n+        data.\n+\n+    store_cv_values : boolean, default=False\n+        Flag indicating if the cross-validation values corresponding to\n+        each alpha should be stored in the `cv_values_` attribute (see\n+        below). This flag is only compatible with `cv=None` (i.e. using\n+        Generalized Cross-Validation).\n+\n     Attributes\n     ----------\n     cv_values_ : array, shape = [n_samples, n_alphas] or \\\n@@ -1333,10 +1353,12 @@ class RidgeClassifierCV(LinearClassifierMixin, _BaseRidgeCV):\n     advantage of the multi-variate response support in Ridge.\n     \"\"\"\n     def __init__(self, alphas=(0.1, 1.0, 10.0), fit_intercept=True,\n-                 normalize=False, scoring=None, cv=None, class_weight=None):\n+                 normalize=False, scoring=None, cv=None, class_weight=None,\n+                 store_cv_values=False, gcv_mode=None):\n         super(RidgeClassifierCV, self).__init__(\n             alphas=alphas, fit_intercept=fit_intercept, normalize=normalize,\n-            scoring=scoring, cv=cv)\n+            scoring=scoring, cv=cv, store_cv_values=store_cv_values,\n+            gcv_mode=gcv_mode)\n         self.class_weight = class_weight\n \n     def fit(self, X, y, sample_weight=None):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14238", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..0ce7de02c6 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2524,7 +2524,7 @@ class AutoFieldMeta(type):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return issubclass(subclass, self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "psf__requests-2317", "model_patch": "diff --git a/requests/models.py b/requests/models.py\nindex 3f6a4f92..ee6ffc3b 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -327,7 +327,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n \n     def prepare_method(self, method):\n         \"\"\"Prepares the given HTTP method.\"\"\"\n-        self.method = method\n+        self.method = to_native_string(method)\n         if self.method is not None:\n             self.method = self.method.upper()\n \ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..adcfbac7 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -425,7 +425,7 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+        method = to_native_string(method)\n \n         # Create the Request.\n         req = Request(\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-16527", "model_patch": "diff --git a/django/contrib/admin/templatetags/admin_modify.py b/django/contrib/admin/templatetags/admin_modify.py\nindex 9df4b7aadb..5b742af46a 100644\n--- a/django/contrib/admin/templatetags/admin_modify.py\n+++ b/django/contrib/admin/templatetags/admin_modify.py\n@@ -100,6 +100,7 @@ def submit_row(context):\n                 and context.get(\"show_delete\", True)\n             ),\n             \"show_save_as_new\": not is_popup\n+            and has_add_permission\n             and has_change_permission\n             and change\n             and save_as,\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sphinx-doc__sphinx-8721", "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..060604e25 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -182,6 +182,8 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-17655", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c978c47be..dbd36b8158 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -120,6 +120,29 @@ def __new__(cls, *args, **kwargs):\n             if len(coords) == kwargs.get('dim', len(coords)):\n                 return coords\n \n+        # If coords is a sympy expression that evaluates to a Point,\n+        # evaluate it manually\n+        from sympy.core.mul import Mul\n+        from sympy.core.add import Add\n+        \n+        if isinstance(coords, Mul):\n+            # Check if exactly one factor is a Point\n+            points = [x for x in coords.args if isinstance(x, Point)]\n+            scalars = [x for x in coords.args if not isinstance(x, Point)]\n+            if len(points) == 1 and len(scalars) >= 1:\n+                # Multiply the point by the product of scalars\n+                scalar_product = Mul(*scalars)\n+                coords = points[0] * scalar_product\n+        \n+        if isinstance(coords, Add):\n+            # Check if all terms are Points\n+            if all(isinstance(x, Point) for x in coords.args):\n+                # Add all the points\n+                result = coords.args[0]\n+                for p in coords.args[1:]:\n+                    result = result + p\n+                coords = result\n+        \n         if not is_sequence(coords):\n             raise TypeError(filldedent('''\n                 Expecting sequence of coordinates, not `{}`'''\n@@ -214,7 +237,7 @@ def __add__(self, other):\n \n         \"\"\"\n         try:\n-            s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n+            s, o = Point._normalize_dimension(self, other, evaluate=False)\n         except TypeError:\n             raise GeometryError(\"Don't know how to add {} and a Point object\".format(other))\n \n@@ -278,6 +301,10 @@ def __mul__(self, factor):\n         coords = [simplify(x*factor) for x in self.args]\n         return Point(coords, evaluate=False)\n \n+    def __rmul__(self, factor):\n+        \"\"\"Reverse multiply point's coordinates by a factor.\"\"\"\n+        return self.__mul__(factor)\n+\n     def __neg__(self):\n         \"\"\"Negate the point.\"\"\"\n         coords = [-x for x in self.args]\n@@ -286,13 +313,18 @@ def __neg__(self):\n     def __sub__(self, other):\n         \"\"\"Subtract two points, or subtract a factor from this point's\n         coordinates.\"\"\"\n-        return self + [-x for x in other]\n+        s, o = Point._normalize_dimension(self, other, evaluate=False)\n+        return s + [-x for x in o]\n \n     @classmethod\n     def _normalize_dimension(cls, *points, **kwargs):\n         \"\"\"Ensure that points have the same dimension.\n         By default `on_morph='warn'` is passed to the\n         `Point` constructor.\"\"\"\n+        # First convert all to Points\n+        kwargs['on_morph'] = kwargs.get('on_morph', 'warn')\n+        points = [Point(i, **kwargs) for i in points]\n+        \n         # if we have a built-in ambient dimension, use it\n         dim = getattr(cls, '_ambient_dimension', None)\n         # override if we specified it\n@@ -303,7 +335,6 @@ def _normalize_dimension(cls, *points, **kwargs):\n         if all(i.ambient_dimension == dim for i in points):\n             return list(points)\n         kwargs['dim'] = dim\n-        kwargs['on_morph'] = kwargs.get('on_morph', 'warn')\n         return [Point(i, **kwargs) for i in points]\n \n     @staticmethod\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11964", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 0a5e5ff673..a68d510478 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -482,7 +482,7 @@ class Model(metaclass=ModelBase):\n                     _setattr(self, field.name, rel_obj)\n             else:\n                 if val is not _DEFERRED:\n-                    _setattr(self, field.attname, val)\n+                    _setattr(self, field.attname, field.to_python(val))\n \n         if kwargs:\n             property_names = opts._property_names\n@@ -492,7 +492,8 @@ class Model(metaclass=ModelBase):\n                     # virtual fields.\n                     if prop in property_names or opts.get_field(prop):\n                         if kwargs[prop] is not _DEFERRED:\n-                            _setattr(self, prop, kwargs[prop])\n+                            field = opts.get_field(prop)\n+                            _setattr(self, prop, field.to_python(kwargs[prop]))\n                         del kwargs[prop]\n                 except (AttributeError, FieldDoesNotExist):\n                     pass\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..334fb98217 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -578,6 +578,9 @@ class Field(RegisterLookupMixin):\n         django.core.exceptions.ValidationError if the data can't be converted.\n         Return the converted value. Subclasses should override this.\n         \"\"\"\n+        import enum\n+        if isinstance(value, enum.Enum):\n+            return value.value\n         return value\n \n     @cached_property\n@@ -931,6 +934,7 @@ class BooleanField(Field):\n         return \"BooleanField\"\n \n     def to_python(self, value):\n+        value = super().to_python(value)\n         if self.null and value in self.empty_values:\n             return None\n         if value in (True, False):\n@@ -1008,6 +1012,7 @@ class CharField(Field):\n         return \"CharField\"\n \n     def to_python(self, value):\n+        value = super().to_python(value)\n         if isinstance(value, str) or value is None:\n             return value\n         return str(value)\n@@ -1149,6 +1154,7 @@ class DateField(DateTimeCheckMixin, Field):\n         return \"DateField\"\n \n     def to_python(self, value):\n+        value = super().to_python(value)\n         if value is None:\n             return value\n         if isinstance(value, datetime.datetime):\n@@ -1767,6 +1773,7 @@ class IntegerField(Field):\n         return \"IntegerField\"\n \n     def to_python(self, value):\n+        value = super().to_python(value)\n         if value is None:\n             return value\n         try:\n@@ -2023,6 +2030,7 @@ class TextField(Field):\n         return \"TextField\"\n \n     def to_python(self, value):\n+        value = super().to_python(value)\n         if isinstance(value, str) or value is None:\n             return value\n         return str(value)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..36cd6f1ed2 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,9 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "pytest-dev__pytest-7432", "model_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..058bf2a38 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,7 +270,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n+    elif item.config.option.runxfail and xfailed:\n         pass  # don't interfere\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13551", "model_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..74f4b30d31 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -85,6 +85,7 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user's email is updated.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +95,10 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Include the email field to invalidate tokens if email changes\n+        email_field_name = getattr(user.__class__, 'get_email_field_name', lambda: 'email')()\n+        email = getattr(user, email_field_name, '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + str(email)\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13158", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..f5a9606671 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1776,6 +1776,12 @@ class Query(BaseExpression):\n         return condition, needed_inner\n \n     def set_empty(self):\n+        \"\"\"Set this query to be empty, regardless of combinator.\"\"\"\n+        # For combined queries, we need to clear combinator info\n+        # because as_sql() ignores WHERE when combinator is set\n+        self.combinator = None\n+        self.combined_queries = None\n+        self.combinator_all = False\n         self.where.add(NothingNode(), AND)\n \n     def is_empty(self):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-24213", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex a436880c4b..5705c821c2 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -175,7 +175,7 @@ def _collect_factor_and_dimension(self, expr):\n             for addend in expr.args[1:]:\n                 addend_factor, addend_dim = \\\n                     self._collect_factor_and_dimension(addend)\n-                if dim != addend_dim:\n+                if not self.get_dimension_system().equivalent_dims(dim, addend_dim):\n                     raise ValueError(\n                         'Dimension of \"{}\" is {}, '\n                         'but it should be {}'.format(\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13315", "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..f993bb9c98 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-13142", "model_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\nindex bd34333c0..8920bef18 100644\n--- a/sklearn/mixture/base.py\n+++ b/sklearn/mixture/base.py\n@@ -257,11 +257,6 @@ class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\n                 best_params = self._get_parameters()\n                 best_n_iter = n_iter\n \n-        # Always do a final e-step to guarantee that the labels returned by\n-        # fit_predict(X) are always consistent with fit(X).predict(X)\n-        # for any value of max_iter and tol (and any random_state).\n-        _, log_resp = self._e_step(X)\n-\n         if not self.converged_:\n             warnings.warn('Initialization %d did not converge. '\n                           'Try different init parameters, '\n@@ -273,6 +268,11 @@ class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\n         self.n_iter_ = best_n_iter\n         self.lower_bound_ = max_lower_bound\n \n+        # Always do a final e-step to guarantee that the labels returned by\n+        # fit_predict(X) are always consistent with fit(X).predict(X)\n+        # for any value of max_iter and tol (and any random_state).\n+        _, log_resp = self._e_step(X)\n+\n         return log_resp.argmax(axis=1)\n \n     def _e_step(self, X):\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sympy__sympy-20590", "model_patch": "diff --git a/sympy/core/_print_helpers.py b/sympy/core/_print_helpers.py\nindex 96d7e72676..40ac1cec31 100644\n--- a/sympy/core/_print_helpers.py\n+++ b/sympy/core/_print_helpers.py\n@@ -16,6 +16,7 @@ class Printable:\n \n     This also adds support for LaTeX printing in jupyter notebooks.\n     \"\"\"\n+    __slots__ = ()\n \n     # Note, we always use the default ordering (lex) in __str__ and __repr__,\n     # regardless of the global setting. See issue 5487.\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "matplotlib__matplotlib-23299", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..c871ac063b 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,24 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    from matplotlib import rcParams, rcParamsDefault\n+    \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        # Resolving auto backend - don't close if already have a backend\n+        if _backend_mod is not None:\n+            # Already have a backend, just make sure rcParams reflects it\n+            # rcParamsDefault should already have the resolved backend\n+            rcParams['backend'] = rcParamsDefault['backend']\n+            return\n+    else:\n+        # Switching to a specific backend\n+        # Check if we're already using this backend\n+        if _backend_mod is not None:\n+            current_backend_name = rcParams['backend']\n+            if current_backend_name == newbackend:\n+                # Already using this backend, no need to close\n+                return\n+        close(\"all\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "sphinx-doc__sphinx-11445", "model_patch": "diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py\nindex 7a1538325..72e042a92 100644\n--- a/sphinx/util/rst.py\n+++ b/sphinx/util/rst.py\n@@ -25,7 +25,7 @@ except ImportError:\n \n logger = logging.getLogger(__name__)\n \n-docinfo_re = re.compile(':\\\\w+:.*?')\n+docinfo_re = re.compile(':\\\\w+:\\\\s+.*')\n symbols_re = re.compile(r'([!-\\-/:-@\\[-`{-~])')  # symbols without dot(0x2e)\n SECTIONING_CHARS = ['=', '-', '~']\n \n@@ -79,11 +79,22 @@ def prepend_prolog(content: StringList, prolog: str) -> None:\n     \"\"\"Prepend a string to content body as prolog.\"\"\"\n     if prolog:\n         pos = 0\n-        for line in content:\n-            if docinfo_re.match(line):\n-                pos += 1\n+        # Skip docinfo block: lines starting with :fieldname: followed by\n+        # optional continuation lines starting with whitespace, until\n+        # a blank line or non-docinfo line\n+        # NOTE: docinfo fields REQUIRE whitespace after the second colon!\n+        # So :author: John is docinfo, but :mod:`foo` is NOT!\n+        while pos < len(content):\n+            line = content[pos]\n+            if pos == 0:\n+                # First line must be a docinfo field\n+                if not docinfo_re.match(line):\n+                    break\n             else:\n-                break\n+                # Subsequent lines are either continuation (indented) or new docinfo field\n+                if not (line.startswith((' ', '\\t')) or docinfo_re.match(line)):\n+                    break\n+            pos += 1\n \n         if pos > 0:\n             # insert a blank line after docinfo\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-15814", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..cf7566d771 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,6 +748,7 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n+                cur_model = cur_model._meta.concrete_model\n                 opts = cur_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11999", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..7879115ee4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,9 @@ class Field(RegisterLookupMixin):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            if 'get_%s_display' % self.name not in cls.__dict__:\n+                setattr(cls, 'get_%s_display' % self.name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-13028", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..7e1cb71ba9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,7 +1124,7 @@ class Query(BaseExpression):\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        if isinstance(expression, BaseExpression) and not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11848", "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..4c352f9557 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -170,12 +170,21 @@ def parse_http_date(date):\n     for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n         m = regex.match(date)\n         if m is not None:\n+            is_rfc850 = (regex is RFC850_DATE)\n             break\n     else:\n         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n     try:\n         year = int(m.group('year'))\n-        if year < 100:\n+        if is_rfc850:  # Only apply special logic to RFC850 (two-digit year format)\n+            current_year = datetime.datetime.utcnow().year\n+            current_century = (current_year // 100) * 100\n+            year += current_century\n+            # If more than 50 years in the future, use previous century\n+            if year - current_year > 50:\n+                year -= 100\n+        elif year < 100:\n+            # Keep backward compatibility for other formats with year < 100\n             if year < 70:\n                 year += 2000\n             else:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-14999", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 982816be3a..e93cc006ff 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -320,31 +320,39 @@ class RenameModel(ModelOperation):\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n-            # Move the main table\n-            schema_editor.alter_db_table(\n-                new_model,\n-                old_model._meta.db_table,\n-                new_model._meta.db_table,\n+            # If db_table didn't change, skip table rename and related field updates\n+            # (but still handle M2M fields as their names are based on model name)\n+            table_name_changed = (\n+                old_model._meta.db_table != new_model._meta.db_table and\n+                not (schema_editor.connection.features.ignores_table_name_case and\n+                    old_model._meta.db_table.lower() == new_model._meta.db_table.lower())\n             )\n-            # Alter the fields pointing to us\n-            for related_object in old_model._meta.related_objects:\n-                if related_object.related_model == old_model:\n-                    model = new_model\n-                    related_key = (app_label, self.new_name_lower)\n-                else:\n-                    model = related_object.related_model\n-                    related_key = (\n-                        related_object.related_model._meta.app_label,\n-                        related_object.related_model._meta.model_name,\n-                    )\n-                to_field = to_state.apps.get_model(\n-                    *related_key\n-                )._meta.get_field(related_object.field.name)\n-                schema_editor.alter_field(\n-                    model,\n-                    related_object.field,\n-                    to_field,\n+            if table_name_changed:\n+                # Move the main table\n+                schema_editor.alter_db_table(\n+                    new_model,\n+                    old_model._meta.db_table,\n+                    new_model._meta.db_table,\n                 )\n+                # Alter the fields pointing to us\n+                for related_object in old_model._meta.related_objects:\n+                    if related_object.related_model == old_model:\n+                        model = new_model\n+                        related_key = (app_label, self.new_name_lower)\n+                    else:\n+                        model = related_object.related_model\n+                        related_key = (\n+                            related_object.related_model._meta.app_label,\n+                            related_object.related_model._meta.model_name,\n+                        )\n+                    to_field = to_state.apps.get_model(\n+                        *related_key\n+                    )._meta.get_field(related_object.field.name)\n+                    schema_editor.alter_field(\n+                        model,\n+                        related_object.field,\n+                        to_field,\n+                    )\n             # Rename M2M fields whose name is based on this model's name.\n             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n             for (old_field, new_field) in fields:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-12308", "model_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex e4ddc8f017..af6c53a9e5 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -379,6 +379,8 @@ def help_text_for_field(name, model):\n \n def display_for_field(value, field, empty_value_display):\n     from django.contrib.admin.templatetags.admin_list import _boolean_icon\n+    from django.db.models.fields.json import JSONField\n+    import json\n \n     if getattr(field, 'flatchoices', None):\n         return dict(field.flatchoices).get(value, empty_value_display)\n@@ -398,6 +400,13 @@ def display_for_field(value, field, empty_value_display):\n         return formats.number_format(value)\n     elif isinstance(field, models.FileField) and value:\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n+    elif isinstance(field, JSONField):\n+        # Use the form field's prepare_value to handle all cases correctly\n+        # including InvalidJSONInput when form validation fails\n+        from django.forms.fields import InvalidJSONInput\n+        if isinstance(value, InvalidJSONInput):\n+            return value\n+        return json.dumps(value, cls=field.encoder)\n     else:\n         return display_for_value(value, empty_value_display)\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-13439", "model_patch": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 7eaf9a46f..243b67e66 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -199,6 +199,10 @@ class Pipeline(_BaseComposition):\n             if trans is not None and trans != 'passthrough':\n                 yield idx, name, trans\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     def __getitem__(self, ind):\n         \"\"\"Returns a sub-pipeline or a single esimtator in the pipeline\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-14894", "model_patch": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..9bf2da976 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -286,12 +286,16 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        if n_SV == 0:\n+            # Handle empty support vectors case\n+            self.dual_coef_ = sp.csr_matrix((n_class, n_SV))\n+        else:\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                         n_SV)\n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "scikit-learn__scikit-learn-25747", "model_patch": "diff --git a/sklearn/utils/_set_output.py b/sklearn/utils/_set_output.py\nindex 335773c6a..815162f74 100644\n--- a/sklearn/utils/_set_output.py\n+++ b/sklearn/utils/_set_output.py\n@@ -127,9 +127,17 @@ def _wrap_data_with_container(method, data_to_wrap, original_input, estimator):\n         return data_to_wrap\n \n     # dense_config == \"pandas\"\n+    pd = check_pandas_support(\"Setting output container to 'pandas'\")\n+    \n+    # Only use original index if data_to_wrap is not already a pandas object\n+    if isinstance(data_to_wrap, (pd.DataFrame, pd.Series)):\n+        index = None\n+    else:\n+        index = getattr(original_input, \"index\", None)\n+    \n     return _wrap_in_pandas_container(\n         data_to_wrap=data_to_wrap,\n-        index=getattr(original_input, \"index\", None),\n+        index=index,\n         columns=estimator.get_feature_names_out,\n     )\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
{"instance_id": "django__django-11133", "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..620f411829 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,10 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+        # Handle buffer protocol objects (bytes-like objects)\n+        # This includes memoryview, bytearray, and other buffer-compatible objects\n+        if isinstance(value, (memoryview, bytearray, bytes)):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n@@ -309,7 +313,8 @@ class HttpResponse(HttpResponseBase):\n     @content.setter\n     def content(self, value):\n         # Consume iterators upon assignment to allow repeated iteration.\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n+        # Check if it's NOT a string/bytes-like object\n+        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str, memoryview, bytearray)):\n             content = b''.join(self.make_bytes(chunk) for chunk in value)\n             if hasattr(value, 'close'):\n                 try:\n", "model_name_or_path": "TRAE_+_Doubao-Seed-Code"}
